---
timestamp: 'Wed Oct 15 2025 19:38:35 GMT-0400 (Eastern Daylight Time)'
content_id: 525219101c18f28727c5287f894b1e277557a35a8d966a41e8700c64d550004b
---

# file: src/concepts/MenuManager/MenuManagerConcept.ts

```typescript
import { Collection, Db, MongoClient } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";
import { GeminiLLM } from "@utils/gemini-llm.ts";

// Declare collection prefix, use concept name
const PREFIX = "MenuManager" + ".";

// Generic types of this concept
type User = ID;
type Menu = ID;
type Recipe = ID;
type Item = ID;
type Cart = ID;

/**
 * Interface for a Menu entity.
 * purpose: creating recipes for full course meals
 * state: a set of Menu with
 *   a name String
 *   an owner User
 *   a menuCost Float
 *   a date String
 *   a set of Recipe (these will be stored in a separate collection, linked by menuId)
 */
interface MenuDoc {
  _id: Menu;
  name: string;
  owner: User;
  menuCost: number; // Calculated, not fixed.
  date: string; // YYYY-MM-DD
}

/**
 * Interface for an ingredient within a Recipe.
 * state: a set of Item with an amount Int (part of Recipe)
 */
interface RecipeIngredient {
  itemId: Item;
  amount: number; // Amount needed for the recipe in its base serving quantity
}

/**
 * Interface for a Recipe entity.
 * state: a set of Recipe with
 *   a set of Item with an amount Int (RecipeIngredient)
 *   a name String
 *   an instructions String
 *   a dishPrice Float
 *   a servingQuantity Int
 *   a scalingFactor Float
 *   a dishType String
 *   an owner User (owner of the menu it belongs to)
 */
interface RecipeDoc {
  _id: Recipe;
  menuId: Menu; // Foreign key to MenuDoc
  name: string;
  instructions: string;
  dishPrice: number; // Calculated.
  servingQuantity: number;
  scalingFactor: number; // Multiplier for ingredients and price
  dishType: string;
  owner: User; // Inherited from menu owner
  ingredients: RecipeIngredient[];
}

/**
 * Interface for a global Item entity.
 * state: a set of Item with
 *   a Set of String names
 *   a price Float
 *   a quantity Float
 *   a units String
 *   a store String
 *   a confirmed Bool
 */
interface ItemDoc {
  _id: Item;
  names: string[]; // Ex. {'pepper', 'ground pepper', 'course pepper'}
  price: number; // Price for the 'quantity' in 'units' (e.g., $3.00 for 1.5 lbs)
  quantity: number; // Quantity available for 'price' (e.g., 1.5 lbs)
  units: string; // Ex. "lbs", "each", "pack"
  store: string;
  confirmed: boolean;
}

/**
 * Interface for a Cart entity.
 * state: a set of Cart with
 *   a startDate String
 *   an endDate String
 *   a set of Menu (linked by menuIds)
 *   a weeklyCost Float
 */
interface CartDoc {
  _id: Cart;
  startDate: string; // "YYYY-MM-DD", must be a Sunday
  endDate: string; // "YYYY-MM-DD", automatically Friday of the same week
  menuIds: Menu[]; // Array of foreign keys to MenuDoc
  weeklyCost: number; // Calculated
}

/**
 * Structure expected from LLM for a parsed recipe.
 */
interface ParsedRecipe {
  name: string;
  instructions: string;
  servingQuantity: number;
  dishType: string;
  ingredients: Array<{ name: string; amount: number }>;
}

/**
 * @concept MenuManager
 * @purpose creating recipes for full course meals
 * @principle A friendly chef embarks on their journey of creating a delicious five course menu with amazing different recipes. They *createMenu* with the specific date of the event and starts by adding their first recipe. Luckily a NEW LLM feature has been added that allows the chef to directly *pullRecipeFromWebsite* using website URL. The LLM is able to parse a good amount of the recipe, but the chef must *updateRecipeIngredient* and *updateRecipe* for a couple things. Unfortunately for the chefs second recipe they have it on paper, but they are still able to enter it in manually. They start by adding their second recipe: *createRecipe*. As they are about to *updateRecipeIngredient* they realize that pumpernickel is not registered as an item they've cooked with before. They then *enterItem* into the system with appropriate price and quantity information, allowing them to *updateRecipeIngredient* to their recipe with the appropriate amount of the ingredient they want have for their recipe. They continue finishing up the recipe when they realize they put the wrong recipe name, and change it via *updateRecipe*. A couple days later once our chef is done adding recipes to their menu, the administrator comes in and sees they added the new pumpernickel ingredient. The administrator figures out what the cost and where to purchase the item and *updateItem* in the system. Finally, the menu is all done and confirmed!
 */
export default class MenuManagerConcept {
  private menus: Collection<MenuDoc>;
  private recipes: Collection<RecipeDoc>;
  private items: Collection<ItemDoc>;
  private carts: Collection<CartDoc>;
  private llm: GeminiLLM; // LLM instance for recipe parsing

  constructor(private readonly db: Db, llmConfig: { apiKey: string }) {
    this.menus = this.db.collection(PREFIX + "menus");
    this.recipes = this.db.collection(PREFIX + "recipes");
    this.items = this.db.collection(PREFIX + "items");
    this.carts = this.db.collection(PREFIX + "carts");
    this.llm = new GeminiLLM(llmConfig);
  }

  // --- Internal Helper Functions ---

  /**
   * Helper to find an item by any of its names.
   * @param name The name to search for.
   * @returns The ItemDoc if found, otherwise null.
   */
  private async findItemByName(name: string): Promise<ItemDoc | null> {
    const item = await this.items.findOne({ names: name });
    return item;
  }

  /**
   * Helper to calculate the price of a single dish, considering its ingredients and scaling factor.
   * @param recipe The recipe document.
   * @returns The calculated dish price.
   */
  private async calculateDishPrice(recipe: RecipeDoc): Promise<number> {
    let price = 0;
    for (const ingredient of recipe.ingredients) {
      const itemDoc = await this.items.findOne({ _id: ingredient.itemId });
      if (itemDoc && itemDoc.quantity > 0) {
        // Price per unit * amount needed
        price += (itemDoc.price / itemDoc.quantity) * ingredient.amount;
      } else if (!itemDoc) {
        console.warn(
          `Ingredient item ${ingredient.itemId} not found for recipe ${recipe._id}`,
        );
      }
    }
    return price * recipe.scalingFactor;
  }

  /**
   * Helper to calculate the total cost of all recipes in a menu.
   * @param menu The menu document.
   * @returns The calculated menu cost.
   */
  private async calculateMenuCost(menu: MenuDoc): Promise<number> {
    const recipesInMenu = await this.recipes.find({ menuId: menu._id })
      .toArray();
    let totalCost = 0;
    for (const recipe of recipesInMenu) {
      totalCost += await this.calculateDishPrice(recipe);
    }
    return totalCost;
  }

  /**
   * Helper to update a menu's stored cost after changes.
   * @param menuId The ID of the menu to update.
   */
  private async updateMenuCost(menuId: Menu): Promise<void> {
    const menu = await this.menus.findOne({ _id: menuId });
    if (menu) {
      const newCost = await this.calculateMenuCost(menu);
      await this.menus.updateOne({ _id: menuId }, {
        $set: { menuCost: newCost },
      });
    }
  }

  /**
   * Helper to calculate the total cost of all menus in a cart.
   * @param cart The cart document.
   * @returns The calculated weekly cost.
   */
  private async calculateCartWeeklyCost(cart: CartDoc): Promise<number> {
    let totalCost = 0;
    for (const menuId of cart.menuIds) {
      const menu = await this.menus.findOne({ _id: menuId });
      if (menu) {
        totalCost += await this.calculateMenuCost(menu);
      }
    }
    return totalCost;
  }

  /**
   * Helper to update a cart's stored weekly cost after changes.
   * @param cartId The ID of the cart to update.
   */
  private async updateCartWeeklyCost(cartId: Cart): Promise<void> {
    const cart = await this.carts.findOne({ _id: cartId });
    if (cart) {
      const newCost = await this.calculateCartWeeklyCost(cart);
      await this.carts.updateOne({ _id: cartId }, {
        $set: { weeklyCost: newCost },
      });
    }
  }

  /**
   * Helper to recalculate all costs (dish, menu, cart) when an item's base properties change.
   * @param itemId The ID of the item that was updated.
   */
  private async recalculateAllCostsForItem(itemId: Item): Promise<void> {
    const recipesUsingItem = await this.recipes.find({
      "ingredients.itemId": itemId,
    }).toArray();
    for (const recipe of recipesUsingItem) {
      // Update dish price for each affected recipe
      await this.recipes.updateOne(
        { _id: recipe._id },
        { $set: { dishPrice: await this.calculateDishPrice(recipe) } },
      );
      // Update menu cost for the menu this recipe belongs to
      await this.updateMenuCost(recipe.menuId);
      // Update cart costs for any carts containing this menu
      const cartsContainingMenu = await this.carts.find({
        menuIds: recipe.menuId,
      }).toArray();
      for (const cart of cartsContainingMenu) {
        await this.updateCartWeeklyCost(cart._id);
      }
    }
  }

  // --- Actions ---

  /**
   * @action createMenu
   * @effects returns new empty menu that is owned by calling user, and has name/date attributes
   */
  async createMenu(
    { name, date, owner }: { name: string; date: string; owner: User },
  ): Promise<{ menu: Menu } | { error: string }> {
    const newMenuId = freshID();
    const newMenu: MenuDoc = {
      _id: newMenuId,
      name,
      owner,
      menuCost: 0,
      date,
    };
    await this.menus.insertOne(newMenu);
    return { menu: newMenuId };
  }

  /**
   * @action updateMenu (name)
   * @requires menu exists, calling user owns menu
   * @effects update the given attribute
   */
  async updateMenuName(
    { menu: menuId, name }: { menu: Menu; name: string },
  ): Promise<Empty | { error: string }> {
    const menu = await this.menus.findOne({ _id: menuId });
    if (!menu) {
      return { error: `Menu with ID "${menuId}" not found.` };
    }
    await this.menus.updateOne({ _id: menuId }, { $set: { name } });
    return {};
  }

  /**
   * @action updateMenu (date)
   * @requires menu exists, calling user owns menu
   * @effects update the given attribute
   */
  async updateMenuDate(
    { menu: menuId, date }: { menu: Menu; date: string },
  ): Promise<Empty | { error: string }> {
    const menu = await this.menus.findOne({ _id: menuId });
    if (!menu) {
      return { error: `Menu with ID "${menuId}" not found.` };
    }
    // Basic date format validation
    if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
      return { error: `Invalid date format "${date}". Expected YYYY-MM-DD.` };
    }
    await this.menus.updateOne({ _id: menuId }, { $set: { date } });
    return {};
  }

  /**
   * @action pullRecipeFromWebsite
   * @requires menu exists, calling user owns menu, recipeURL is a valid URL
   * @effects Using an LLM prompt to parse through the online recipeURL, creates recipe with all the information that it was able to parse and user can *updateIngredient* as necessary
   */
  async pullRecipeFromWebsite(
    { menu: menuId, recipeURL, owner }: {
      menu: Menu;
      recipeURL: string;
      owner: User;
    },
  ): Promise<{ recipe: Recipe } | { error: string }> {
    const menu = await this.menus.findOne({ _id: menuId, owner });
    if (!menu) {
      return {
        error: `Menu with ID "${menuId}" not found or not owned by user.`,
      };
    }

    // Basic URL validation
    try {
      new URL(recipeURL);
    } catch {
      return { error: "Invalid recipeURL provided." };
    }

    console.log(`ü§ñ Requesting recipe parse for URL: ${recipeURL}`);
    const prompt = this.createPullRecipePrompt(recipeURL);
    let responseText: string;
    try {
      responseText = await this.llm.executeLLM(prompt);
      console.log("‚úÖ Received response from Gemini AI!");
    } catch (llmError) {
      return { error: `LLM API call failed: ${(llmError as Error).message}` };
    }

    try {
      const jsonMatch = responseText.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        return { error: "No JSON object found in the LLM response." };
      }

      const parsed: ParsedRecipe = JSON.parse(jsonMatch[0]);
      if (
        !parsed.name || !parsed.instructions || !parsed.servingQuantity ||
        !parsed.dishType || !parsed.ingredients
      ) {
        return { error: "The parsed JSON is missing required fields." };
      }

      // Semantic validation: check if ingredients are mentioned in instructions
      let mentionedIngredients = 0;
      const instructionsText = parsed.instructions.toLowerCase();
      for (const ing of parsed.ingredients) {
        const coreName = ing.name.split(" ").pop()?.toLowerCase() ?? ""; // Get last word for simpler match
        if (coreName && instructionsText.includes(coreName)) {
          mentionedIngredients++;
        }
      }

      const mentionedPercentage = (parsed.ingredients.length > 0)
        ? (mentionedIngredients / parsed.ingredients.length) * 100
        : 100;
      if (parsed.ingredients.length > 0 && mentionedPercentage < 75) {
        console.warn(
          `‚ö†Ô∏è Semantic Validation Failed: Only ${
            mentionedPercentage.toFixed(0)
          }% of ingredients are mentioned in the instructions. This might indicate a poor parse or mismatched data.`,
        );
        // For now, allow it but log a warning. Could be a hard error depending on business logic.
      } else if (parsed.ingredients.length > 0) {
        console.log(
          `‚úÖ Instructions: ${
            mentionedPercentage.toFixed(0)
          }% of ingredients are mentioned, likely matching.`,
        );
      }

      // Create the recipe document
      const newRecipeId = freshID();
      const newRecipeDoc: RecipeDoc = {
        _id: newRecipeId,
        menuId: menuId,
        name: parsed.name,
        instructions: parsed.instructions,
        dishPrice: 0, // Will be calculated after ingredients are added and persisted
        servingQuantity: parsed.servingQuantity,
        scalingFactor: 1.0, // Default scaling factor
        dishType: parsed.dishType,
        owner: owner,
        ingredients: [], // Initialize empty, then add
      };
      await this.recipes.insertOne(newRecipeDoc);

      // Add ingredients from the parsed recipe, creating placeholder items if necessary
      const recipeIngredients: RecipeIngredient[] = [];
      for (const ing of parsed.ingredients) {
        let itemDoc = await this.findItemByName(ing.name);
        if (!itemDoc) {
          // Create a placeholder item. 'owner' is not specified for enterItem as per instructions to ignore.
          const placeholderItemResult = await this.enterItem({
            name: ing.name,
            price: 0, // Placeholder price
            quantity: 1, // Placeholder quantity
            units: "unknown", // Placeholder units
            store: "unknown", // Placeholder store
          });
          if ("error" in placeholderItemResult) {
            console.warn(
              `Could not create placeholder item "${ing.name}": ${placeholderItemResult.error}. Skipping this ingredient.`,
            );
            continue;
          }
          itemDoc = await this.items.findOne({
            _id: placeholderItemResult.item,
          });
          if (!itemDoc) {
            console.error(
              `Failed to retrieve newly created placeholder item ${placeholderItemResult.item}. This should not happen.`,
            );
            continue;
          }
        }
        recipeIngredients.push({ itemId: itemDoc._id, amount: ing.amount });
      }

      // Update recipe with all collected ingredients
      await this.recipes.updateOne(
        { _id: newRecipeId },
        { $set: { ingredients: recipeIngredients } },
      );

      // Recalculate dish and menu costs
      const updatedRecipeDoc = {
        ...newRecipeDoc,
        ingredients: recipeIngredients,
      }; // Temporary for calculation
      updatedRecipeDoc.dishPrice = await this.calculateDishPrice(
        updatedRecipeDoc,
      );
      await this.recipes.updateOne({ _id: newRecipeId }, {
        $set: { dishPrice: updatedRecipeDoc.dishPrice },
      });
      await this.updateMenuCost(menuId);

      // Also update cart cost if this menu is in any cart
      const cartsContainingMenu = await this.carts.find({ menuIds: menuId })
        .toArray();
      for (const cart of cartsContainingMenu) {
        await this.updateCartWeeklyCost(cart._id);
      }

      console.log(
        `‚úÖ Successfully parsed and stored recipe: "${updatedRecipeDoc.name}"`,
      );
      return { recipe: newRecipeId };
    } catch (parseError) {
      console.error(
        "‚ùå Error parsing LLM response or adding recipe:",
        (parseError as Error).message,
      );
      return {
        error: `Failed to process LLM response: ${
          (parseError as Error).message
        }`,
      };
    }
  }

  /**
   * Helper for LLM prompt generation.
   * @param url The URL to parse.
   * @returns The prompt string for the LLM.
   */
  private createPullRecipePrompt(url: string): string {
    return `Analyze the recipe content from the provided URL and extract the recipe details into a structured JSON format.

    **Recipe URL to analyze:** ${url}

    **CRITICAL OUTPUT REQUIREMENTS:**
    *   Return ONLY a single JSON object. Do not include any surrounding text, explanations, or markdown formatting.
    *   The JSON must follow this exact structure. Omit any fields where a value cannot be found or is irrelevant. Ensure ingredient amounts are numerical (float or int).

    {
      "name": "The Exact Recipe Name",
      "instructions": "1. First step from the recipe. 2. Second step from the recipe.",
      "servingQuantity": 8,
      "dishType": "Main Course",
      "ingredients": [
        { "name": "boneless skinless chicken breasts", "amount": 1.5 },
        { "name": "olive oil", "amount": 1 },
        { "name": "salt", "amount": 0.5 },
        { "name": "black pepper", "amount": 0.25 }
      ]
    }`;
  }

  /**
   * @action createRecipe
   * @requires menu exists, calling user owns menu
   * @effects adds recipe with no ingredients to the menu
   */
  async createRecipe(
    {
      menu: menuId,
      name,
      instructions,
      servingQuantity,
      dishType,
      scalingFactor,
      owner,
    }: {
      menu: Menu;
      name: string;
      instructions: string;
      servingQuantity: number;
      dishType: string;
      scalingFactor: number;
      owner: User;
    },
  ): Promise<{ recipe: Recipe } | { error: string }> {
    const menu = await this.menus.findOne({ _id: menuId, owner });
    if (!menu) {
      return {
        error: `Menu with ID "${menuId}" not found or not owned by user.`,
      };
    }
    if (servingQuantity <= 0) {
      return { error: `Serving quantity must be a positive number.` };
    }
    if (scalingFactor < 0) {
      return { error: `Scaling factor cannot be negative.` };
    }

    const newRecipeId = freshID();
    const newRecipe: RecipeDoc = {
      _id: newRecipeId,
      menuId,
      name,
      instructions,
      servingQuantity,
      dishType,
      scalingFactor,
      owner,
      dishPrice: 0, // Will be calculated after ingredients are added
      ingredients: [],
    };
    await this.recipes.insertOne(newRecipe);

    // Recalculate menu cost and then cart cost
    await this.updateMenuCost(menuId);
    const cartsContainingMenu = await this.carts.find({ menuIds: menuId })
      .toArray();
    for (const cart of cartsContainingMenu) {
      await this.updateCartWeeklyCost(cart._id);
    }

    return { recipe: newRecipeId };
  }

  /**
   * @action updateRecipeIngredient
   * @requires menu exists, recipe exists in menu, calling user owns menu
   * @effects recipe updated to have appropriate scaling of item; dishPrice and menuCost reflect new change
   */
  async updateRecipeIngredient(
    { menu: menuId, recipe: recipeId, item: itemId, amount }: {
      menu: Menu;
      recipe: Recipe;
      item: Item;
      amount: number;
    },
  ): Promise<Empty | { error: string }> {
    const recipe = await this.recipes.findOne({ _id: recipeId, menuId });
    if (!recipe) {
      return {
        error: `Recipe with ID "${recipeId}" not found in menu "${menuId}".`,
      };
    }
    if (amount < 0) {
      return { error: `Ingredient amount cannot be negative.` };
    }

    // Check if item exists in global item list
    const itemDoc = await this.items.findOne({ _id: itemId });
    if (!itemDoc) {
      return { error: `Item with ID "${itemId}" not found.` };
    }

    const existingIngredientIndex = recipe.ingredients.findIndex(
      (ing) => ing.itemId === itemId,
    );

    if (amount === 0) {
      // If amount is 0, remove the ingredient
      if (existingIngredientIndex !== -1) {
        recipe.ingredients.splice(existingIngredientIndex, 1);
      }
    } else {
      if (existingIngredientIndex !== -1) {
        recipe.ingredients[existingIngredientIndex].amount = amount;
      } else {
        recipe.ingredients.push({ itemId, amount });
      }
    }

    await this.recipes.updateOne({ _id: recipeId }, {
      $set: { ingredients: recipe.ingredients },
    });

    // Recalculate dish price
    recipe.dishPrice = await this.calculateDishPrice(recipe);
    await this.recipes.updateOne({ _id: recipeId }, {
      $set: { dishPrice: recipe.dishPrice },
    });

    // Recalculate menu cost and then cart cost
    await this.updateMenuCost(menuId);
    const cartsContainingMenu = await this.carts.find({ menuIds: menuId })
      .toArray();
    for (const cart of cartsContainingMenu) {
      await this.updateCartWeeklyCost(cart._id);
    }

    return {};
  }

  /**
   * @action updateRecipe (instructions)
   * @requires menu exists, recipe exists in menu, calling user owns menu
   * @effects update the given attribute
   */
  async updateRecipeInstructions(
    { menu: menuId, recipe: recipeId, instructions }: {
      menu: Menu;
      recipe: Recipe;
      instructions: string;
    },
  ): Promise<Empty | { error: string }> {
    const recipe = await this.recipes.findOne({ _id: recipeId, menuId });
    if (!recipe) {
      return {
        error: `Recipe with ID "${recipeId}" not found in menu "${menuId}".`,
      };
    }
    await this.recipes.updateOne({ _id: recipeId }, { $set: { instructions } });
    return {};
  }

  /**
   * @action updateRecipe (servingQuantity)
   * @requires menu exists, recipe exists in menu, calling user owns menu
   * @effects update the given attribute
   */
  async updateRecipeServingQuantity(
    { menu: menuId, recipe: recipeId, servingQuantity }: {
      menu: Menu;
      recipe: Recipe;
      servingQuantity: number;
    },
  ): Promise<Empty | { error: string }> {
    const recipe = await this.recipes.findOne({ _id: recipeId, menuId });
    if (!recipe) {
      return {
        error: `Recipe with ID "${recipeId}" not found in menu "${menuId}".`,
      };
    }
    if (servingQuantity <= 0) {
      return { error: `Serving quantity must be a positive number.` };
    }
    await this.recipes.updateOne({ _id: recipeId }, {
      $set: { servingQuantity },
    });
    // Note: Changing servingQuantity directly does not change ingredient amounts in this model,
    // as 'amount' in RecipeIngredient is for the base serving quantity. Scaling is handled by scalingFactor.
    // Therefore, no cost recalculation is needed here.
    return {};
  }

  /**
   * @action updateRecipe (scalingFactor)
   * @requires menu exists, recipe exists in menu, calling user owns menu
   * @effects update the given attribute
   */
  async updateRecipeScalingFactor(
    { menu: menuId, recipe: recipeId, scalingFactor }: {
      menu: Menu;
      recipe: Recipe;
      scalingFactor: number;
    },
  ): Promise<Empty | { error: string }> {
    const recipe = await this.recipes.findOne({ _id: recipeId, menuId });
    if (!recipe) {
      return {
        error: `Recipe with ID "${recipeId}" not found in menu "${menuId}".`,
      };
    }
    if (scalingFactor < 0) {
      return { error: `Scaling factor cannot be negative.` };
    }
    await this.recipes.updateOne({ _id: recipeId }, {
      $set: { scalingFactor },
    });

    // Recalculate dish, menu, and cart costs
    const updatedRecipe = { ...recipe, scalingFactor }; // Create temporary updated recipe for calculation
    updatedRecipe.dishPrice = await this.calculateDishPrice(updatedRecipe);
    await this.recipes.updateOne({ _id: recipeId }, {
      $set: { dishPrice: updatedRecipe.dishPrice },
    });

    await this.updateMenuCost(menuId);
    const cartsContainingMenu = await this.carts.find({ menuIds: menuId })
      .toArray();
    for (const cart of cartsContainingMenu) {
      await this.updateCartWeeklyCost(cart._id);
    }
    return {};
  }

  /**
   * @action updateRecipe (dishType)
   * @requires menu exists, recipe exists in menu, calling user owns menu
   * @effects update the given attribute
   */
  async updateRecipeDishType(
    { menu: menuId, recipe: recipeId, dishType }: {
      menu: Menu;
      recipe: Recipe;
      dishType: string;
    },
  ): Promise<Empty | { error: string }> {
    const recipe = await this.recipes.findOne({ _id: recipeId, menuId });
    if (!recipe) {
      return {
        error: `Recipe with ID "${recipeId}" not found in menu "${menuId}".`,
      };
    }
    await this.recipes.updateOne({ _id: recipeId }, { $set: { dishType } });
    return {};
  }

  /**
   * @action updateRecipe (name)
   * @requires menu exists, recipe exists in menu, calling user owns menu
   * @effects update the given attribute
   */
  async updateRecipeName(
    { menu: menuId, recipe: recipeId, name }: {
      menu: Menu;
      recipe: Recipe;
      name: string;
    },
  ): Promise<Empty | { error: string }> {
    const recipe = await this.recipes.findOne({ _id: recipeId, menuId });
    if (!recipe) {
      return {
        error: `Recipe with ID "${recipeId}" not found in menu "${menuId}".`,
      };
    }
    await this.recipes.updateOne({ _id: recipeId }, { $set: { name } });
    return {};
  }

  /**
   * @action enterItem
   * @requires no Item already exists with name
   * @effects returns and stores new item, confirmed flag set to false
   */
  async enterItem(
    { name, price, quantity, units, store }: {
      name: string;
      price: number;
      quantity: number;
      units: string;
      store: string;
    },
  ): Promise<{ item: Item } | { error: string }> {
    // Check if an item with this specific name already exists
    const existingItem = await this.items.findOne({ names: name });
    if (existingItem) {
      return {
        error:
          `An item already exists with the name "${name}". Use addItemName to add an alias.`,
      };
    }
    if (price < 0) {
      return { error: "Price cannot be negative." };
    }
    if (quantity <= 0) {
      return { error: "Quantity must be positive." };
    }

    const newItemId = freshID();
    const newItem: ItemDoc = {
      _id: newItemId,
      names: [name], // Start with the primary name
      price,
      quantity,
      units,
      store,
      confirmed: false,
    };
    await this.items.insertOne(newItem);
    return { item: newItemId };
  }

  /**
   * @action confirmItem
   * @requires item exists, item hasn't been confirmed yet, called by Administrator
   * @effects returned item is now confirmed
   */
  async confirmItem(
    { item: itemId }: { item: Item },
  ): Promise<{ item: Item } | { error: string }> {
    const item = await this.items.findOne({ _id: itemId });
    if (!item) {
      return { error: `Item with ID "${itemId}" not found.` };
    }
    if (item.confirmed) {
      return { error: `Item with ID "${itemId}" is already confirmed.` };
    }
    await this.items.updateOne({ _id: itemId }, { $set: { confirmed: true } });
    return { item: itemId };
  }

  /**
   * @action updateItem (price)
   * @requires item exists, called by Administrator
   * @effects update the given attribute
   */
  async updateItemPrice(
    { item: itemId, price }: { item: Item; price: number },
  ): Promise<Empty | { error: string }> {
    const item = await this.items.findOne({ _id: itemId });
    if (!item) {
      return { error: `Item with ID "${itemId}" not found.` };
    }
    if (price < 0) {
      return { error: `Price cannot be negative.` };
    }
    await this.items.updateOne({ _id: itemId }, { $set: { price } });
    await this.recalculateAllCostsForItem(itemId); // Recalculate all affected costs
    return {};
  }

  /**
   * @action updateItem (quantity)
   * @requires item exists, called by Administrator
   * @effects update the given attribute
   */
  async updateItemQuantity(
    { item: itemId, quantity }: { item: Item; quantity: number },
  ): Promise<Empty | { error: string }> {
    const item = await this.items.findOne({ _id: itemId });
    if (!item) {
      return { error: `Item with ID "${itemId}" not found.` };
    }
    if (quantity <= 0) {
      return { error: `Quantity must be positive.` };
    }
    await this.items.updateOne({ _id: itemId }, { $set: { quantity } });
    await this.recalculateAllCostsForItem(itemId); // Recalculate all affected costs
    return {};
  }

  /**
   * @action updateItem (units)
   * @requires item exists, called by Administrator
   * @effects update the given attribute
   */
  async updateItemUnits(
    { item: itemId, units }: { item: Item; units: string },
  ): Promise<Empty | { error: string }> {
    const item = await this.items.findOne({ _id: itemId });
    if (!item) {
      return { error: `Item with ID "${itemId}" not found.` };
    }
    await this.items.updateOne({ _id: itemId }, { $set: { units } });
    return {};
  }

  /**
   * @action updateItem (store)
   * @requires item exists, called by Administrator
   * @effects update the given attribute
   */
  async updateItemStore(
    { item: itemId, store }: { item: Item; store: string },
  ): Promise<Empty | { error: string }> {
    const item = await this.items.findOne({ _id: itemId });
    if (!item) {
      return { error: `Item with ID "${itemId}" not found.` };
    }
    await this.items.updateOne({ _id: itemId }, { $set: { store } });
    return {};
  }

  /**
   * @action addItemName
   * @requires item exists, called by Administrator
   * @effects item now has new name that it can be referenced by
   */
  async addItemName(
    { item: itemId, name }: { item: Item; name: string },
  ): Promise<Empty | { error: string }> {
    const item = await this.items.findOne({ _id: itemId });
    if (!item) {
      return { error: `Item with ID "${itemId}" not found.` };
    }
    if (item.names.includes(name)) {
      return { error: `Item "${itemId}" already has name "${name}".` };
    }
    // Check if this new name is already used by another item
    const existingItemWithSameName = await this.items.findOne({
      _id: { $ne: itemId },
      names: name,
    });
    if (existingItemWithSameName) {
      return { error: `Name "${name}" is already used by another item.` };
    }
    await this.items.updateOne({ _id: itemId }, { $push: { names: name } });
    return {};
  }

  /**
   * @action removeItemName
   * @requires item exists, item has name, called by Administrator
   * @effects item can no longer be referenced by name
   */
  async removeItemName(
    { item: itemId, name }: { item: Item; name: string },
  ): Promise<Empty | { error: string }> {
    const item = await this.items.findOne({ _id: itemId });
    if (!item) {
      return { error: `Item with ID "${itemId}" not found.` };
    }
    if (!item.names.includes(name)) {
      return { error: `Item "${itemId}" does not have name "${name}".` };
    }
    if (item.names.length === 1) {
      return { error: `Cannot remove the last name of an item.` };
    }
    await this.items.updateOne({ _id: itemId }, { $pull: { names: name } });
    return {};
  }

  /**
   * @action createCart
   * @requires startDate is a Sunday, no cart already exists with startDate
   * @effects creates empty cart with startDate and endDate that Friday
   */
  async createCart(
    { startDate }: { startDate: string },
  ): Promise<{ cart: Cart } | { error: string }> {
    // Validate startDate is a Sunday
    const dateObj = new Date(startDate + "T00:00:00Z"); // Ensure UTC to avoid timezone issues for date only string
    if (isNaN(dateObj.getTime())) {
      return { error: "Invalid startDate format. Expected YYYY-MM-DD." };
    }
    if (dateObj.getUTCDay() !== 0) { // Sunday is 0 (0-6 for Sun-Sat)
      return { error: `startDate "${startDate}" is not a Sunday.` };
    }

    // Check if cart already exists for this startDate
    const existingCart = await this.carts.findOne({ startDate });
    if (existingCart) {
      return { error: `A cart already exists for startDate "${startDate}".` };
    }

    // Calculate endDate (Friday of the same week)
    const endDateObj = new Date(dateObj);
    endDateObj.setUTCDate(dateObj.getUTCDate() + 5); // Add 5 days to get to Friday
    const endDate = endDateObj.toISOString().split("T")[0];

    const newCartId = freshID();
    const newCart: CartDoc = {
      _id: newCartId,
      startDate,
      endDate,
      menuIds: [],
      weeklyCost: 0,
    };
    await this.carts.insertOne(newCart);
    return { cart: newCartId };
  }

  /**
   * @action addMenuToCart
   * @requires cart exists, menu exists, cart doesn't already have a menu for that menus date
   * @effects adds menu to the cart and appropriately adjusts cart price
   */
  async addMenuToCart(
    { cart: cartId, menu: menuId }: { cart: Cart; menu: Menu },
  ): Promise<Empty | { error: string }> {
    const cart = await this.carts.findOne({ _id: cartId });
    if (!cart) {
      return { error: `Cart with ID "${cartId}" not found.` };
    }
    const menu = await this.menus.findOne({ _id: menuId });
    if (!menu) {
      return { error: `Menu with ID "${menuId}" not found.` };
    }

    // Check if a menu for that date already exists in the cart
    const menusInCart = await this.menus.find({ _id: { $in: cart.menuIds } })
      .toArray();
    if (menusInCart.some((m) => m.date === menu.date)) {
      return {
        error:
          `Cart "${cartId}" already contains a menu for date "${menu.date}".`,
      };
    }

    await this.carts.updateOne({ _id: cartId }, { $push: { menuIds: menuId } });
    await this.updateCartWeeklyCost(cartId); // Recalculate weekly cost

    return {};
  }

  /**
   * @action adjustRecipeScale
   * @requires cart, menu, and recipe all exist, recipe in menu, menu in cart
   * @effects within the cart adjusts to have the new scaling factor of specified recipe in menu, adjust cart price appropriately
   */
  async adjustRecipeScale(
    { cart: cartId, menu: menuId, recipe: recipeId, scalingFactor }: {
      cart: Cart;
      menu: Menu;
      recipe: Recipe;
      scalingFactor: number;
    },
  ): Promise<Empty | { error: string }> {
    const cart = await this.carts.findOne({ _id: cartId, menuIds: menuId }); // Verify cart contains menu
    if (!cart) {
      return {
        error:
          `Cart "${cartId}" does not exist or does not contain menu "${menuId}".`,
      };
    }
    const recipe = await this.recipes.findOne({ _id: recipeId, menuId }); // Verify recipe is in menu
    if (!recipe) {
      return { error: `Recipe "${recipeId}" not found in menu "${menuId}".` };
    }
    if (scalingFactor < 0) {
      return { error: `Scaling factor cannot be negative.` };
    }

    // Update the recipe's scaling factor directly
    await this.recipes.updateOne({ _id: recipeId }, {
      $set: { scalingFactor },
    });

    // Recalculate costs: dish, menu, and then cart
    const updatedRecipe = { ...recipe, scalingFactor }; // Create temporary updated recipe for calculation
    updatedRecipe.dishPrice = await this.calculateDishPrice(updatedRecipe);
    await this.recipes.updateOne({ _id: recipeId }, {
      $set: { dishPrice: updatedRecipe.dishPrice },
    });

    await this.updateMenuCost(menuId);
    await this.updateCartWeeklyCost(cartId);

    return {};
  }

  /**
   * @action adjustItemQuantity
   * @requires cart, menu, and item all exist, item in some recipe in menu, menu in cart
   * @effects within the cart adjusts number of item purchased to quantity, adjust cart price appropriately
   */
  async adjustItemQuantity(
    { cart: cartId, menu: menuId, item: itemId, quantity }: {
      cart: Cart;
      menu: Menu;
      item: Item;
      quantity: number;
    },
  ): Promise<Empty | { error: string }> {
    const cart = await this.carts.findOne({ _id: cartId, menuIds: menuId });
    if (!cart) {
      return {
        error:
          `Cart "${cartId}" does not exist or does not contain menu "${menuId}".`,
      };
    }
    const menu = await this.menus.findOne({ _id: menuId });
    if (!menu) {
      return { error: `Menu "${menuId}" not found.` };
    }
    const itemDoc = await this.items.findOne({ _id: itemId });
    if (!itemDoc) {
      return { error: `Item with ID "${itemId}" not found.` };
    }
    if (quantity <= 0) {
      return { error: `Quantity must be positive.` };
    }

    // Verify the item is actually used in a recipe within this menu
    const recipesUsingItemInMenu = await this.recipes.countDocuments({
      menuId: menuId,
      "ingredients.itemId": itemId,
    });
    if (recipesUsingItemInMenu === 0) {
      return {
        error:
          `Item "${itemId}" is not used in any recipe within menu "${menuId}".`,
      };
    }

    // As per interpretation, this action updates the global `ItemDoc.quantity`.
    // The "adjusts number of item purchased to quantity" implies changing the fundamental quantity
    // associated with an item's price, thereby affecting how costs are calculated for all uses.
    const updateResult = await this.items.updateOne({ _id: itemId }, {
      $set: { quantity },
    });
    if (updateResult.modifiedCount === 0) {
      return { error: `Failed to update item "${itemId}" quantity.` };
    }

    await this.recalculateAllCostsForItem(itemId); // Recalculate all affected costs, including cart
    await this.updateCartWeeklyCost(cartId); // Explicitly update this specific cart
    return {};
  }

  // --- Queries ---

  /**
   * @query _getMenusInCart
   * @requires cart exists
   * @effects returns the set of all Menu entities associated with the given cart.
   */
  async _getMenusInCart(
    { cart: cartId }: { cart: Cart },
  ): Promise<{ menus: MenuDoc[] } | { error: string }> {
    const cart = await this.carts.findOne({ _id: cartId });
    if (!cart) {
      return { error: `Cart with ID "${cartId}" not found.` };
    }
    const menus = await this.menus.find({ _id: { $in: cart.menuIds } })
      .toArray();
    return { menus };
  }

  /**
   * @query _getRecipesInMenu
   * @requires menu exists
   * @effects returns the set of all Recipe entities associated with the given menu.
   */
  async _getRecipesInMenu(
    { menu: menuId }: { menu: Menu },
  ): Promise<{ recipes: RecipeDoc[] } | { error: string }> {
    const menu = await this.menus.findOne({ _id: menuId });
    if (!menu) {
      return { error: `Menu with ID "${menuId}" not found.` };
    }
    const recipes = await this.recipes.find({ menuId }).toArray();
    return { recipes };
  }

  /**
   * @query _getIngredientsInRecipe
   * @requires recipe exists
   * @effects returns a map where each key is an Item and the value is the total scaled quantity (Float) of that item needed for the given recipe, calculated as `item.amount * recipe.scalingFactor`. The `Item`'s `units` property indicates the unit of the quantity.
   */
  async _getIngredientsInRecipe(
    { recipe: recipeId }: { recipe: Recipe },
  ): Promise<
    { ingredients: Record<Item, { amount: number; units: string }> } | {
      error: string;
    }
  > {
    const recipe = await this.recipes.findOne({ _id: recipeId });
    if (!recipe) {
      return { error: `Recipe with ID "${recipeId}" not found.` };
    }

    const ingredientsMap: Record<Item, { amount: number; units: string }> = {};
    for (const ing of recipe.ingredients) {
      const item = await this.items.findOne({ _id: ing.itemId });
      if (item) {
        ingredientsMap[item._id] = {
          amount: ing.amount * recipe.scalingFactor,
          units: item.units,
        };
      } else {
        console.warn(`Item ${ing.itemId} not found for recipe ${recipeId}`);
      }
    }
    return { ingredients: ingredientsMap };
  }

  /**
   * @query _getIngredientsInMenu
   * @requires menu exists
   * @effects returns a map where each key is an Item and the value is the total aggregated quantity (Float) of that item needed across all recipes within the given menu, considering each recipe's `scalingFactor`. The `Item`'s `units` property indicates the unit of the quantity.
   */
  async _getIngredientsInMenu(
    { menu: menuId }: { menu: Menu },
  ): Promise<
    { ingredients: Record<Item, { amount: number; units: string }> } | {
      error: string;
    }
  > {
    const menu = await this.menus.findOne({ _id: menuId });
    if (!menu) {
      return { error: `Menu with ID "${menuId}" not found.` };
    }

    const recipesInMenu = await this.recipes.find({ menuId }).toArray();
    const aggregatedIngredients: Record<
      Item,
      { amount: number; units: string }
    > = {};

    for (const recipe of recipesInMenu) {
      for (const ing of recipe.ingredients) {
        const item = await this.items.findOne({ _id: ing.itemId });
        if (item) {
          const scaledAmount = ing.amount * recipe.scalingFactor;
          if (aggregatedIngredients[item._id]) {
            aggregatedIngredients[item._id].amount += scaledAmount;
          } else {
            aggregatedIngredients[item._id] = {
              amount: scaledAmount,
              units: item.units,
            };
          }
        } else {
          console.warn(
            `Item ${ing.itemId} not found for recipe ${recipe._id} in menu ${menuId}`,
          );
        }
      }
    }
    return { ingredients: aggregatedIngredients };
  }

  /**
   * @query _getListOfItems
   * @requires nothing
   * @effects returns a set of all items stored within the application.
   */
  async _getListOfItems(): Promise<{ items: ItemDoc[] }> {
    const items = await this.items.find({}).toArray();
    return { items };
  }

  /**
   * @query _getIngredientsPerStore
   * @requires all menus in the input set exist
   * @effects returns a map where each key is a `store` name (String) and the value is another map. This inner map has `Item` keys and their total aggregated quantity (Float) values, representing the total amount of each item needed from that store across all specified menus, considering recipe scaling factors. The `Item`'s `units` property indicates the unit of the quantity.
   */
  async _getIngredientsPerStore(
    { menus: menuIds }: { menus: Menu[] },
  ): Promise<
    {
      storeShoppingList: Record<
        string,
        Record<Item, { amount: number; units: string }>
      >;
    }
  > {
    const storeShoppingList: Record<
      string,
      Record<Item, { amount: number; units: string }>
    > = {};

    for (const menuId of menuIds) {
      const menu = await this.menus.findOne({ _id: menuId });
      if (!menu) {
        console.warn(`Menu ${menuId} not found, skipping.`);
        continue;
      }

      const menuIngredientsResult = await this._getIngredientsInMenu({
        menu: menuId,
      });
      if ("error" in menuIngredientsResult) {
        console.warn(
          `Error getting ingredients for menu ${menuId}: ${menuIngredientsResult.error}`,
        );
        continue;
      }
      const menuIngredients = menuIngredientsResult.ingredients;

      for (const itemId in menuIngredients) {
        const { amount, units } = menuIngredients[itemId];
        const item = await this.items.findOne({ _id: itemId as ID });
        if (item) {
          if (!storeShoppingList[item.store]) {
            storeShoppingList[item.store] = {};
          }
          if (storeShoppingList[item.store][item._id]) {
            storeShoppingList[item.store][item._id].amount += amount;
          } else {
            storeShoppingList[item.store][item._id] = { amount, units };
          }
        } else {
          console.warn(`Item ${itemId} not found when aggregating for stores.`);
        }
      }
    }
    return { storeShoppingList };
  }

  /**
   * @query _getMenuByDate
   * @requires menu exists for date
   * @effects returns the menu associated with that date.
   */
  async _getMenuByDate(
    { date }: { date: string },
  ): Promise<{ menu: MenuDoc } | { error: string }> {
    const menu = await this.menus.findOne({ date });
    if (!menu) {
      return { error: `Menu for date "${date}" not found.` };
    }
    return { menu };
  }

  /**
   * @query _getMenusOwnedByUser
   * @requires user exists
   * @effects returns the set of all Menu entities where the `owner` attribute matches the given user.
   */
  async _getMenusOwnedByUser(
    { user: ownerId }: { user: User },
  ): Promise<{ menus: MenuDoc[] }> {
    const menus = await this.menus.find({ owner: ownerId }).toArray();
    return { menus };
  }
}

```
