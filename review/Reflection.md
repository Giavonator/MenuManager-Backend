# Reflection

## What was hard or easy?

### Difficult

- Concept Design: Creating a robust, scalable, modular, application that solves a real world problem has proven quite difficult.
- Time Estimation: At every step of the project I have not properly estimated the amount of time it would take.
- Frontend/Backend Documentation: Once both were setup, it was difficult to constantly have to move documentation across repos to keep everything to date.

### Easy

- Implementation: After learning effect workflows with Cursor and Context, the actual implementation of the code became trivial.
- Front end iteration: With LLM's it was easy to iterate on design choices/ideas with front end design.

## What mistakes did you make, and how would you avoid making them in the future?

Overall the biggest mistake that I felt I made was choosing this application problem. I originally thought it would be feasible, but after +100 hours of working on the project it became a huge time commitment affecting my other classes. After a certain point I had to call the application done, even though I knew there were still improvements that could be made.

I find myself to be a very ambitious person, but I've learned that biting more than you can chew sometimes can be a lot worse. In the future I will focus on being honest with how long things will take, giving myself buffer time, and then making a decision.

## What skills did you acquire and which do you feel you still need to develop further?

- Agentic Coding: At least with Cursor, after the hours of developing I've learned there is a particular nice workflow using the "Ask + "Plan" + "Agent" features to get coding done. By breaking up features through this process, I found that I remained in control of the code changes, understood what was happening, and effectively used LLMs to enhance my workflow.
- MongoDB: This was my first exposure *really* implementing something with persistent storage, and after going through the learning curve I feel accomplished knowing how storage happens with full stack applications.
- Server/Client/Syncs/HTTP: Although I understood everything that the LLM was implementing, I feel that I should develop these skills by implementing more of it on my own. I'm not confident enough yet to say that I am would be able to re implement everything in my project on my own, in regards to the server, client, sync engine, etc.

## How did you use the Context tool?

- Brainstorming: Getting ideas on specific things that I wanted to complete.
- Documentation: With several files reflecting the state of concepts, making a change in one place and pointing to where the change should propogate really reduced documentation time.
- Implementation: After concepts were thoroughly designed and Context had the in detail implementation details, it was very easy to implement what I needed (usually 1-2 shot as well).

## What conclusions would you draw about the appropriate role of LLMs in software development?

Overall, I think that LLMs in software development can be very useful in speeding up the time it takes to make applications. At one point during development I had four small features I wanted to make, knew exactly how to make them, and each would roughly take 30 minutes end to end. Instead I ran four different agents to implement them, and in 10 minutes all of them were done.

Although, LLMs due heavily detract from the learning process. I have felt I've gotten a lot of exposure from using MongoDB, client server systems, etc. but if you were to ask me what the API was to add a document to MongoDB I couldn't tell you. When the calculator came out people were concerned that they didn't have to memorize times tables anymore, so my question is whether this is the same for LLMs?
